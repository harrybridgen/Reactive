import bootstrap.stable.grammar;
import bootstrap.stable.util;
import bootstrap.stable.tokenizer;
import bootstrap.stable.parser;
import std.file;
import std.buf;

struct LabelGen {
    counter = 0;
}

struct TextBuf {
    buf;
    first = 1;
}

func textbuf_new(cap) {
    out := struct TextBuf;
    out.buf = buf_new(cap);
    out.first = 1;
    return out;
}

func textbuf_line_start(out) {
    if out.first == 0 {
        buf_push_char(out.buf, '\n');
    }
    else {
        out.first = 0;
    }
}

func textbuf_push(out, s) {
    buf_push_str(out.buf, s);
}

func textbuf_push_char(out, c) {
    buf_push_char(out.buf, c);
}

func textbuf_finish(out) {
    return buf_to_string(out.buf);
}

func append_int(out, n) {
    textbuf_push(out, str_from_int(n));
}

func append_quoted(out, s) {
    textbuf_push_char(out, '"');

    i = 0;
    di ::= i + 1;
    loop {
        if i >= s { break; }
        c := s[i];
        ci := (int)c;

        if c == '\\' {
            textbuf_push(out, "\\\\");
        }
        else if c == '"' {
            textbuf_push(out, "\\\"");
        }
        else if c == '\n' {
            textbuf_push(out, "\\n");
        }
        else if c == '\r' {
            textbuf_push(out, "\\r");
        }
        else if c == '\t' {
            textbuf_push(out, "\\t");
        }
        else if ci < 32 || ci > 126 {
            textbuf_push(out, "\\u{");
            textbuf_push(out, str_from_hex(ci));
            textbuf_push_char(out, '}');
        }
        else {
            textbuf_push_char(out, c);
        }

        i = di;
    }

    textbuf_push_char(out, '"');
}

func new_labelgen() {
    lg := struct LabelGen;
    lg.counter = 0;
    return lg;
}

func label_fresh(lg, prefix) {
    name := str_append(prefix, "_");
    name = str_append(name, str_from_int(lg.counter));
    lg.counter = lg.counter + 1;
    return name;
}

func vec_contains_str(v, s) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= v.len { break; }
        if str_equals(v.items[i], s) {
            return 1;
        }
        i = di;
    }
    return 0;
}

func vec_push_unique(v, s) {
    if vec_contains_str(v, s) {
        return;
    }
    vec_push(v, s);
}

func vec_sort_strings(v) {
    i = 1;
    di ::= i + 1;
    loop {
        if i >= v.len { break; }
        key := v.items[i];
        j = i - 1;
        loop {
            if j < 0 { break; }
            if str_compare(v.items[j], key) <= 0 { break; }
            v.items[j + 1] = v.items[j];
            j = j - 1;
        }
        v.items[j + 1] = key;
        i = di;
    }
}

func join_segments(parts, sep) {
    out := str_empty();
    i = 0;
    di ::= i + 1;
    loop {
        if i >= parts { break; }
        if i > 0 {
            out = str_append(out, sep);
        }
        out = str_append(out, parts[i]);
        i = di;
    }
    return out;
}

func compile_source(src) {
    lex := tokenize(src);
    ast := parse(lex.tokens, lex.len);

    code := vec_new(64);
    labels := new_labelgen();
    break_stack := vec_new(8);
    continue_stack := vec_new(8);
    imports := vec_new(8);
    println "[Reactive] Compiler"
    compile(ast, code, labels, break_stack, continue_stack, imports);
    return vec_to_array(code);
}

func compile_source_module(src) {
    lex := tokenize(src);
    ast := parse(lex.tokens, lex.len);

    code := vec_new(64);
    labels := new_labelgen();
    break_stack := vec_new(8);
    continue_stack := vec_new(8);
    imports := vec_new(8);
    println "[Reactive] Compiler (module)"
    compile_module(ast, code, labels, break_stack, continue_stack, imports);
    return vec_to_array(code);
}

func compile_file(input_path, output_path) {
    src := file_read(input_path);
    code := compile_source(src);
    println "[Reactive] Serialize";
    text := serialize_instructions(code);
    println "[Reactive] Write file";
    file_write(output_path, text);
}

func compile_file_module(input_path, output_path) {
    src := file_read(input_path);
    code := compile_source_module(src);
    println "[Reactive] Serialize";
    text := serialize_instructions(code);
    println "[Reactive] Write file";
    file_write(output_path, text);
}

func compile_module(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Program {
        items := ast.list;
        i = 0;
        di ::= i + 1;
        loop {
            if i >= items { break; }
            compile(items[i], code, labels, break_stack, continue_stack, imports);
            i = di;
        }
    }
    else {
        compile(ast, code, labels, break_stack, continue_stack, imports);
    }
}

func compile(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Number {
        value := ast.a;
        inst := instr1(INSTR_Push, value);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Char {
        value := ast.a;
        inst := instr1(INSTR_PushChar, value);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_String {
        value := ast.a;
        compile_string_literal(value, code, labels);
        return;
    }
    if ast.kind == AST_Var {
        inst := instr1(INSTR_Load, ast.name);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_ArrayNew {
        size := ast.a;
        compile(size, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayNew);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        compile(base, code, labels, break_stack, continue_stack, imports);
        compile(index, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayGet);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        compile(base, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_FieldGet, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Operation {
        left := ast.a;
        right := ast.b;
        compile(left, code, labels, break_stack, continue_stack, imports);
        compile(right, code, labels, break_stack, continue_stack, imports);
        emit_operator(ast.op, code);
        return;
    }
    if ast.kind == AST_Ternary {
        cond := ast.a;
        then_expr := ast.b;
        else_expr := ast.c;
        compile(cond, code, labels, break_stack, continue_stack, imports);

        else_lbl := label_fresh(labels, "ternary_else");
        end_lbl := label_fresh(labels, "ternary_end");

        inst := instr1(INSTR_JumpIfZero, else_lbl);
        vec_push(code, inst);
        compile(then_expr, code, labels, break_stack, continue_stack, imports);
        inst = instr1(INSTR_Jump, end_lbl);
        vec_push(code, inst);

        inst = instr1(INSTR_Label, else_lbl);
        vec_push(code, inst);
        compile(else_expr, code, labels, break_stack, continue_stack, imports);

        inst = instr1(INSTR_Label, end_lbl);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Call {
        args := ast.list;
        i = 0;
        di ::= i + 1;
        loop {
            if i >= args { break; }
            compile(args[i], code, labels, break_stack, continue_stack, imports);
            i = di;
        }
        inst := instr2(INSTR_Call, ast.name, (int)args);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Assign {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_Store, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ImmutableAssign {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_StoreImmutable, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ReactiveAssign {
        value := ast.a;
        reactive := compile_reactive_expr(value, imports);
        name := ast.name;
        inst := instr2(INSTR_StoreReactive, name, reactive);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_AssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_StoreThrough);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ReactiveAssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        reactive := compile_reactive_expr(value, imports);
        inst := instr1(INSTR_StoreThroughReactive, reactive);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ImmutableAssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_StoreThroughImmutable);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAssign {
        if ast.flag == FIELD_ASSIGN_Normal {
            base := ast.a;
            value := ast.b;
            compile(base, code, labels, break_stack, continue_stack, imports);
            compile(value, code, labels, break_stack, continue_stack, imports);
            name := ast.name;
            inst := instr1(INSTR_FieldSet, name);
            vec_push(code, inst);
            return;
        }
        if ast.flag == FIELD_ASSIGN_Reactive {
            base := ast.a;
            value := ast.b;
            compile(base, code, labels, break_stack, continue_stack, imports);
            reactive := compile_reactive_expr(value, imports);
            name := ast.name;
            inst := instr2(INSTR_FieldSetReactive, name, reactive);
            vec_push(code, inst);
            return;
        }
        error "compiler: immutable field assignment not allowed";
    }

    if ast.kind == AST_IfElse {
        cond := ast.a;
        then_block := ast.b;
        else_block := ast.c;
        compile(cond, code, labels, break_stack, continue_stack, imports);

        else_lbl := label_fresh(labels, "else");
        end_lbl := label_fresh(labels, "ifend");

        inst := instr1(INSTR_JumpIfZero, else_lbl);
        vec_push(code, inst);

        inst = instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        compile_block(then_block, code, labels, break_stack, continue_stack, imports);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        inst = instr1(INSTR_Jump, end_lbl);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, else_lbl);
        vec_push(code, inst);

        inst = instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        compile_block(else_block, code, labels, break_stack, continue_stack, imports);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        inst = instr1(INSTR_Label, end_lbl);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Loop {
        start := label_fresh(labels, "loop_start");
        end := label_fresh(labels, "loop_end");

        vec_push(break_stack, end);
        vec_push(continue_stack, start);

        inst := instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, start);
        vec_push(code, inst);
        inst = instr0(INSTR_ClearImmutableContext);
        vec_push(code, inst);

        compile_block(ast.list, code, labels, break_stack, continue_stack, imports);

        inst = instr1(INSTR_Jump, start);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, end);
        vec_push(code, inst);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        vec_pop(break_stack);
        vec_pop(continue_stack);
        return;
    }

    if ast.kind == AST_Break {
        label := vec_last(break_stack);
        inst := instr1(INSTR_Jump, label);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Continue {
        label := vec_last(continue_stack);
        inst := instr1(INSTR_Jump, label);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Return {
        if ast.flag == 1 {
            value := ast.a;
            compile(value, code, labels, break_stack, continue_stack, imports);
        }
        else {
            inst := instr1(INSTR_Push, 0);
            vec_push(code, inst);
        }
        inst = instr0(INSTR_Return);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_FuncDef {
        func_code := compile_function_body(ast.body, imports);
        inst := instr3(INSTR_StoreFunction, ast.name, ast.params, func_code);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_StructDef {
        fields := compile_struct_fields(ast.list, imports);
        inst := instr2(INSTR_StoreStruct, ast.name, fields);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_StructNew {
        inst := instr1(INSTR_NewStruct, ast.name);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Import {
        compile_import(ast.list, code, labels, break_stack, continue_stack, imports);
        return;
    }

    if ast.kind == AST_Program {
        items := ast.list;
        has_main = 0;

        i = 0;
        di ::= i + 1;
        loop {
            if i >= items { break; }
            item := items[i];
            if item.kind == AST_FuncDef {
                if str_equals(item.name, "main") {
                    has_main = 1;
                }
            }
            compile(item, code, labels, break_stack, continue_stack, imports);
            i = di;
        }

        if has_main == 0 {
            error "no `main` function defined";
        }

        inst := instr2(INSTR_Call, "main", 0);
        vec_push(code, inst);
        inst = instr0(INSTR_Return);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Print {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Print);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Println {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Println);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Assert {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Assert);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Error {
        msg := ast.a;
        inst := instr1(INSTR_Error, msg);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Cast {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        flag := ast.flag;
        inst := instr1(INSTR_Cast, flag);
        vec_push(code, inst);
        return;
    }

    error "compiler: unknown AST node";
}

func compile_block(block, code, labels, break_stack, continue_stack, imports) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= block { break; }
        compile(block[i], code, labels, break_stack, continue_stack, imports);
        i = di;
    }
}

func compile_function_body(body, imports) {
    code := vec_new(16);
    labels := new_labelgen();
    break_stack := vec_new(4);
    continue_stack := vec_new(4);

    compile_block(body, code, labels, break_stack, continue_stack, imports);
    inst := instr0(INSTR_Return);
    vec_push(code, inst);
    return vec_to_array(code);
}

func compile_struct_fields(fields, imports) {
    out := vec_new(8);
    i = 0;
    di ::= i + 1;
    loop {
        if i >= fields { break; }
        f := fields[i];
        if f.kind == FIELD_INIT_None {
            init := field_init(f.name, FIELD_INIT_None, 0);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Mutable {
            code := compile_expr_to_code(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Mutable, code);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Immutable {
            code := compile_expr_to_code(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Immutable, code);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Reactive {
            reactive := compile_reactive_expr(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Reactive, reactive);
            vec_push(out, init);
        }
        else {
            error "compiler: unknown field init kind";
        }
        i = di;
    }
    return vec_to_array(out);
}

func compile_expr_to_code(ast, imports) {
    code := vec_new(8);
    labels := new_labelgen();
    break_stack := vec_new(4);
    continue_stack := vec_new(4);

    compile(ast, code, labels, break_stack, continue_stack, imports);
    inst := instr0(INSTR_Return);
    vec_push(code, inst);
    return vec_to_array(code);
}

func compile_reactive_expr(ast, imports) {
    names := vec_new(8);
    collect_free_vars(ast, names);
    vec_sort_strings(names);
    code := compile_expr_to_code(ast, imports);
    return reactive_expr(vec_to_array(names), code);
}

func collect_free_vars_list(list, out) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= list { break; }
        collect_free_vars(list[i], out);
        i = di;
    }
}

func collect_free_vars(ast, out) {
    if ast.kind == AST_Var {
        vec_push_unique(out, ast.name);
        return;
    }
    if ast.kind == AST_Operation {
        left := ast.a;
        right := ast.b;
        collect_free_vars(left, out);
        collect_free_vars(right, out);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        collect_free_vars(base, out);
        collect_free_vars(index, out);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        collect_free_vars(base, out);
        return;
    }
    if ast.kind == AST_Ternary {
        cond := ast.a;
        then_expr := ast.b;
        else_expr := ast.c;
        collect_free_vars(cond, out);
        collect_free_vars(then_expr, out);
        collect_free_vars(else_expr, out);
        return;
    }
    if ast.kind == AST_Call {
        collect_free_vars_list(ast.list, out);
        return;
    }
    if ast.kind == AST_ArrayNew {
        size := ast.a;
        collect_free_vars(size, out);
        return;
    }
    if ast.kind == AST_Assign ||
    ast.kind == AST_ImmutableAssign ||
    ast.kind == AST_ReactiveAssign {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_AssignTarget || ast.kind == AST_ReactiveAssignTarget {
        target := ast.a;
        value := ast.b;
        collect_free_vars(target, out);
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_ImmutableAssignTarget {
        value := ast.b;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_FieldAssign {
        base := ast.a;
        value := ast.b;
        collect_free_vars(base, out);
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_Cast {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_Assert {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
}

func compile_lvalue(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Var {
        name := ast.name;
        inst := instr1(INSTR_Load, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        compile_lvalue(base, code, labels, break_stack, continue_stack, imports);
        compile(index, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayLValue);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        compile_lvalue(base, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_FieldLValue, name);
        vec_push(code, inst);
        return;
    }
    error "compiler: invalid assignment target";
}

func compile_import(path, code, labels, break_stack, continue_stack, imports) {
    inst := instr1(INSTR_Import, path);
    vec_push(code, inst);

    module_name := join_segments(path, ".");
    if vec_contains_str(imports, module_name) {
        return;
    }
    vec_push(imports, module_name);

    rel_path := join_segments(path, "/");
    file_path := str_append("project/", rel_path);
    file_path = str_append(file_path, ".rx");

    source := file_read(file_path);
    lex := tokenize(source);
    ast := parse(lex.tokens, lex.len);

    compile_module(ast, code, labels, break_stack, continue_stack, imports);
}

func emit_operator(op, code) {
    if op == OP_Add { inst := instr0(INSTR_Add); vec_push(code, inst); return; }
    if op == OP_Sub { inst := instr0(INSTR_Sub); vec_push(code, inst); return; }
    if op == OP_Mul { inst := instr0(INSTR_Mul); vec_push(code, inst); return; }
    if op == OP_Div { inst := instr0(INSTR_Div); vec_push(code, inst); return; }
    if op == OP_Mod { inst := instr0(INSTR_Modulo); vec_push(code, inst); return; }
    if op == OP_Greater { inst := instr0(INSTR_Greater); vec_push(code, inst); return; }
    if op == OP_Less { inst := instr0(INSTR_Less); vec_push(code, inst); return; }
    if op == OP_GreaterEqual { inst := instr0(INSTR_GreaterEqual); vec_push(code, inst); return; }
    if op == OP_LessEqual { inst := instr0(INSTR_LessEqual); vec_push(code, inst); return; }
    if op == OP_Equal { inst := instr0(INSTR_Equal); vec_push(code, inst); return; }
    if op == OP_NotEqual { inst := instr0(INSTR_NotEqual); vec_push(code, inst); return; }
    if op == OP_And { inst := instr0(INSTR_And); vec_push(code, inst); return; }
    if op == OP_Or { inst := instr0(INSTR_Or); vec_push(code, inst); return; }
    error "compiler: unknown operator";
}

func compile_string_literal(s, code, labels) {
    len := str_len(s);
    inst := instr1(INSTR_Push, len);
    vec_push(code, inst);
    inst = instr0(INSTR_ArrayNew);
    vec_push(code, inst);

    tmp := label_fresh(labels, "__strlit");
    inst = instr1(INSTR_Store, tmp);
    vec_push(code, inst);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= len { break; }
        inst = instr1(INSTR_Load, tmp);
        vec_push(code, inst);
        inst = instr1(INSTR_Push, i);
        vec_push(code, inst);
        inst = instr0(INSTR_ArrayLValue);
        vec_push(code, inst);
        inst = instr1(INSTR_PushChar, s[i]);
        vec_push(code, inst);
        inst = instr0(INSTR_StoreThrough);
        vec_push(code, inst);
        i = di;
    }

    inst = instr1(INSTR_Load, tmp);
    vec_push(code, inst);
}

func serialize_instructions(code) {
    out := textbuf_new(1024);
    textbuf_line_start(out);
    textbuf_push(out, "RXB1");
    append_instructions(out, code);
    return textbuf_finish(out);
}

func append_instructions(out, code) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= code { break; }
        append_instruction(out, code[i]);
        i = di;
    }
}

func append_instruction(out, instr) {
    if instr.kind == INSTR_Push {
        textbuf_line_start(out);
        textbuf_push(out, "Push ");
        append_int(out, instr.a);
        return;
    }
    if instr.kind == INSTR_PushChar {
        textbuf_line_start(out);
        textbuf_push(out, "PushChar ");
        append_int(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Load {
        textbuf_line_start(out);
        textbuf_push(out, "Load ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Store {
        textbuf_line_start(out);
        textbuf_push(out, "Store ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreImmutable {
        textbuf_line_start(out);
        textbuf_push(out, "StoreImmutable ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreReactive {
        append_reactive_named(out, "StoreReactive", instr.a, instr.b);
        return;
    }

    if instr.kind == INSTR_Add { textbuf_line_start(out); textbuf_push(out, "Add"); return; }
    if instr.kind == INSTR_Sub { textbuf_line_start(out); textbuf_push(out, "Sub"); return; }
    if instr.kind == INSTR_Mul { textbuf_line_start(out); textbuf_push(out, "Mul"); return; }
    if instr.kind == INSTR_Div { textbuf_line_start(out); textbuf_push(out, "Div"); return; }
    if instr.kind == INSTR_Modulo { textbuf_line_start(out); textbuf_push(out, "Modulo"); return; }

    if instr.kind == INSTR_Greater { textbuf_line_start(out); textbuf_push(out, "Greater"); return; }
    if instr.kind == INSTR_Less { textbuf_line_start(out); textbuf_push(out, "Less"); return; }
    if instr.kind == INSTR_GreaterEqual { textbuf_line_start(out); textbuf_push(out, "GreaterEqual"); return; }
    if instr.kind == INSTR_LessEqual { textbuf_line_start(out); textbuf_push(out, "LessEqual"); return; }
    if instr.kind == INSTR_Equal { textbuf_line_start(out); textbuf_push(out, "Equal"); return; }
    if instr.kind == INSTR_NotEqual { textbuf_line_start(out); textbuf_push(out, "NotEqual"); return; }
    if instr.kind == INSTR_And { textbuf_line_start(out); textbuf_push(out, "And"); return; }
    if instr.kind == INSTR_Or { textbuf_line_start(out); textbuf_push(out, "Or"); return; }

    if instr.kind == INSTR_Label {
        textbuf_line_start(out);
        textbuf_push(out, "Label ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Jump {
        textbuf_line_start(out);
        textbuf_push(out, "Jump ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_JumpIfZero {
        textbuf_line_start(out);
        textbuf_push(out, "JumpIfZero ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Return {
        textbuf_line_start(out);
        textbuf_push(out, "Return");
        return;
    }

    if instr.kind == INSTR_ArrayNew { textbuf_line_start(out); textbuf_push(out, "ArrayNew"); return; }
    if instr.kind == INSTR_ArrayGet { textbuf_line_start(out); textbuf_push(out, "ArrayGet"); return; }
    if instr.kind == INSTR_ArrayLValue { textbuf_line_start(out); textbuf_push(out, "ArrayLValue"); return; }

    if instr.kind == INSTR_StoreIndex {
        textbuf_line_start(out);
        textbuf_push(out, "StoreIndex ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreIndexReactive {
        append_reactive_named(out, "StoreIndexReactive", instr.a, instr.b);
        return;
    }

    if instr.kind == INSTR_StoreStruct {
        append_store_struct(out, instr.a, instr.b);
        return;
    }
    if instr.kind == INSTR_NewStruct {
        textbuf_line_start(out);
        textbuf_push(out, "NewStruct ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldGet {
        textbuf_line_start(out);
        textbuf_push(out, "FieldGet ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldSet {
        textbuf_line_start(out);
        textbuf_push(out, "FieldSet ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldSetReactive {
        append_reactive_named(out, "FieldSetReactive", instr.a, instr.b);
        return;
    }
    if instr.kind == INSTR_FieldLValue {
        textbuf_line_start(out);
        textbuf_push(out, "FieldLValue ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_StoreThrough { textbuf_line_start(out); textbuf_push(out, "StoreThrough"); return; }
    if instr.kind == INSTR_StoreThroughReactive {
        append_reactive_unnamed(out, "StoreThroughReactive", instr.a);
        return;
    }
    if instr.kind == INSTR_StoreThroughImmutable {
        textbuf_line_start(out);
        textbuf_push(out, "StoreThroughImmutable");
        return;
    }

    if instr.kind == INSTR_StoreFunction {
        append_store_function(out, instr.a, instr.b, instr.c);
        return;
    }
    if instr.kind == INSTR_Call {
        textbuf_line_start(out);
        textbuf_push(out, "Call ");
        append_quoted(out, instr.a);
        textbuf_push(out, " ");
        append_int(out, instr.b);
        return;
    }

    if instr.kind == INSTR_PushImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "PushImmutableContext");
        return;
    }
    if instr.kind == INSTR_PopImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "PopImmutableContext");
        return;
    }
    if instr.kind == INSTR_ClearImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "ClearImmutableContext");
        return;
    }

    if instr.kind == INSTR_Print { textbuf_line_start(out); textbuf_push(out, "Print"); return; }
    if instr.kind == INSTR_Println { textbuf_line_start(out); textbuf_push(out, "Println"); return; }
    if instr.kind == INSTR_Assert { textbuf_line_start(out); textbuf_push(out, "Assert"); return; }
    if instr.kind == INSTR_Error {
        textbuf_line_start(out);
        textbuf_push(out, "Error ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Import {
        append_import(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Cast {
        textbuf_line_start(out);
        textbuf_push(out, "Cast ");
        if instr.a == CAST_Int {
            textbuf_push(out, "Int");
        }
        else {
            textbuf_push(out, "Char");
        }
        return;
    }

    error "serialize: unknown instruction";
}

func append_import(out, path) {
    textbuf_line_start(out);
    textbuf_push(out, "Import ");
    append_int(out, (int)path);
    i = 0;
    di ::= i + 1;
    loop {
        if i >= path { break; }
        textbuf_push(out, " ");
        append_quoted(out, path[i]);
        i = di;
    }
}

func append_store_function(out, name, params, body) {
    textbuf_line_start(out);
    textbuf_push(out, "StoreFunction ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)params);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= params { break; }
        textbuf_push(out, " ");
        append_quoted(out, params[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)body);

    append_instructions(out, body);
}

func append_store_struct(out, name, fields) {
    textbuf_line_start(out);
    textbuf_push(out, "StoreStruct ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)fields);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= fields { break; }
        append_struct_field(out, fields[i]);
        i = di;
    }
}

func append_struct_field(out, field) {
    if field.kind == FIELD_INIT_None {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " None");
        return;
    }

    if field.kind == FIELD_INIT_Mutable {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Mutable ");
        append_int(out, (int)field.value);
        append_instructions(out, field.value);
        return;
    }

    if field.kind == FIELD_INIT_Immutable {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Immutable ");
        append_int(out, (int)field.value);
        append_instructions(out, field.value);
        return;
    }

    if field.kind == FIELD_INIT_Reactive {
        expr := field.value;
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Reactive ");
        append_int(out, (int)expr.captures);

        i = 0;
        di ::= i + 1;
        loop {
            if i >= expr.captures { break; }
            textbuf_push(out, " ");
            append_quoted(out, expr.captures[i]);
            i = di;
        }

        textbuf_push(out, " ");
        append_int(out, (int)expr.code);

        append_instructions(out, expr.code);
        return;
    }

    error "serialize: unknown field init";
}

func append_reactive_named(out, keyword, name, expr) {
    textbuf_line_start(out);
    textbuf_push(out, keyword);
    textbuf_push(out, " ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)expr.captures);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= expr.captures { break; }
        textbuf_push(out, " ");
        append_quoted(out, expr.captures[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)expr.code);

    append_instructions(out, expr.code);
}

func append_reactive_unnamed(out, keyword, expr) {
    textbuf_line_start(out);
    textbuf_push(out, keyword);
    textbuf_push(out, " ");
    append_int(out, (int)expr.captures);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= expr.captures { break; }
        textbuf_push(out, " ");
        append_quoted(out, expr.captures[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)expr.code);

    append_instructions(out, expr.code);
}

