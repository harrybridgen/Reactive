import compiler.grammar;

struct Parser {
    tokens;
    len = 0;
    pos = 0;
}

func new_parser(tokens, len){
    p := struct Parser;
    p.tokens := tokens;
    p.len = len;
    p.pos = 0;
    return p;
}

func peek(p) {
    if p.pos >= p.len { return 0; }
    return p.tokens[p.pos].kind;
}

func advance(p) {
    p.pos = p.pos + 1;
}

func parse_number(p) {
    t := p.tokens[p.pos];
    advance(p);
    n := nodeNum(t.ival);
    return n;
}
func parse_primary(p) {
    if peek(p) == TK_Number {
        return parse_number(p);
    }
    else if peek(p) == TK_LParen {
        advance(p);
        expr := parse_expr(p);
        if peek(p) != TK_RParen {
            println "error: expected LBracket";
            return 0;
        }
        advance(p);
        return expr;
    }
    else {
        println "error: expected primary expression";
        return 0;
    }
}
func parse_mul(p) {
    expr := parse_primary(p);

    loop {
        if peek(p) == TK_Mul {
            advance(p);
            rhs := parse_primary(p);
            expr = nodeOper(AST_Mul, expr, rhs);
        }
        else if peek(p) == TK_Div {
            advance(p);
            rhs := parse_primary(p);
            expr = nodeOper(AST_Div, expr, rhs);
        }
        else {
            break;
        }
    }

    return expr;
}
func parse_expr(p) {
    expr := parse_mul(p);

    loop {
        if peek(p) == TK_Add {
            advance(p);
            rhs := parse_mul(p);
            expr = nodeOper(AST_Add, expr, rhs);
        }
        else if peek(p) == TK_Sub {
            advance(p);
            rhs := parse_mul(p);
            expr = nodeOper(AST_Sub, expr, rhs);
        }
        else {
            break;
        }
    }

    return expr;
}


