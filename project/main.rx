struct Vec2 {
    x = 0;
    y = 0;
}

func new_vec_array(n) {
    V := [n];

    i = 0;
    di ::= i + 1;

    loop {
        if i >= n { break; }
        V[i] = struct Vec2;
        i = di;
    }

    return V;
}

func new_matrix(rows, cols) {
    M := [rows];

    i = 0;
    di ::= i + 1;

    loop {
        if i >= rows { break; }
        M[i] = [cols];
        i = di;
    }

    return M;
}

func init_vec_values(V, x0, y0, dx, dy) {
    i = 0;
    di ::= i + 1;

    loop {
        if i >= V { break; }

        V[i].x = x0 + i * dx;
        V[i].y = y0 + i * dy;

        i = di;
    }
}



func bind_dot_products(M, A, B) {
    i = 0;
    di ::= i + 1;

    loop {
        if i >= A { break; }

        j = 0;
        dj ::= j + 1;

        loop {
            if j >= B { break; }

            ii := i;
            jj := j;

            M[ii][jj] ::=
                A[ii].x * B[jj].x +
                A[ii].y * B[jj].y;

            j = dj;
        }

        i = di;
    }
}

func print_matrix(M) {
    i = 0;
    di ::= i + 1;

    loop {
        if i >= M { break; }

        j = 0;
        dj ::= j + 1;

        loop {
            if j >= M[i] { break; }
            println M[i][j];
            j = dj;
        }

        i = di;
    }
}

A = new_vec_array(3);
B = new_vec_array(3);

# A = [(1,2), (3,4), (5,6)] #
init_vec_values(A, 1, 2, 2, 2);

# B = [(7,8), (9,10), (11,12)] #
init_vec_values(B, 7, 8, 2, 2);

M = new_matrix(A, B);
bind_dot_products(M, A, B);

# ---- initial matrix ---- #
print_matrix(M);

# ---- mutate vectors ---- #
A[1].x = 100;
B[2].y = 1;
println ' ';

# ---- matrix updates automatically ---- #
print_matrix(M);
