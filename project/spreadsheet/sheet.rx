import std.input;
import std.str;
import std.maths;

struct Screen {
    width;
    height;
    buf;
}

func new_screen(width, height) {
    screen := struct Screen;
    screen.width := width;
    screen.height := height;
    screen.buf := [screen.height];

    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        screen.buf[y] = [screen.width];
        y = dy;
    }
    return screen;
}

func clear_buf(screen) {
    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        x = 0;
        dx ::= x + 1;
        loop {
            if x >= screen.width { break; }
            screen.buf[y][x] = ' ';
            x = dx;
        }
        y = dy;
    }
}

func put_char(screen, x, y, c) {
    if x < 0 || y < 0 { return 0; }
    if x >= screen.width || y >= screen.height { return 0; }
    screen.buf[y][x] = c;
    return 0;
}

func put_str(screen, x, y, s) {
    n := (int)s;
    i = 0;
    di ::= i + 1;
    loop {
        if i >= n { break; }
        put_char(screen, x + i, y, s[i]);
        i = di;
    }
}

func draw_hline(screen, x0, x1, y, c) {
    x = x0;
    dx ::= x + 1;
    loop {
        if x > x1 { break; }
        put_char(screen, x, y, c);
        x = dx;
    }
}

func draw_vline(screen, x, y0, y1, c) {
    y = y0;
    dy ::= y + 1;
    loop {
        if y > y1 { break; }
        put_char(screen, x, y, c);
        y = dy;
    }
}

func draw_box(screen, x0, y0, x1, y1) {
    draw_hline(screen, x0 + 1, x1 - 1, y0, '-');
    draw_hline(screen, x0 + 1, x1 - 1, y1, '-');
    draw_vline(screen, x0, y0 + 1, y1 - 1, '|');
    draw_vline(screen, x1, y0 + 1, y1 - 1, '|');
    put_char(screen, x0, y0, '+');
    put_char(screen, x1, y0, '+');
    put_char(screen, x0, y1, '+');
    put_char(screen, x1, y1, '+');
}

func cell_label(cx, cy) {
    col := (char)((int)'A' + cx);
    row := str_from_int(cy + 1);
    out := str_empty();
    out = str_append_char(out, col);
    out = str_append(out, row);
    return out;
}

func framebuffer(
screen,
cursor_x_px,
cursor_y_px,
cell_name,
cell_value,
cell_type,
status_line,
grid_cols,
grid_rows,
cells,
edit_mode,
edit_buffer
) {
    clear_buf(screen);

    title := "ReactiveSheet";
    w := screen.width;

    row_label_width = 3;
    cell_w = 4;

    grid_start_x = 1 + row_label_width;
    grid_start_y = 2;

    sep1_y = grid_start_y + grid_rows + 1;
    info_y = sep1_y + 1;
    sep2_y = info_y + 3;
    status_y = sep2_y + 1;

    draw_box(screen, 0, 0, w - 1, screen.height - 1);

    put_str(screen, (w - (int)title) / 2, 0, title);

    draw_hline(screen, 1, w - 2, sep1_y, '-');
    draw_hline(screen, 1, w - 2, sep2_y, '-');

    put_str(screen, 1, info_y + 0, str_append("Cell: ", cell_name));
    if edit_mode {
        put_str(screen, 1, info_y + 1, str_append("Edit: ", edit_buffer));
    }
    else {
        put_str(screen, 1, info_y + 1, str_append("Value: ", cell_value));
    }
    put_str(screen, 1, info_y + 2, str_append("Type: ", cell_type));

    put_str(screen, 1, status_y, status_line);

    c = 0;
    dc ::= c + 1;
    loop {
        if c >= grid_cols { break; }
        col_x = grid_start_x + (c * cell_w) + 1;
        put_char(screen, col_x, 1, (char)((int)'A' + c));
        c = dc;
    }

    r = 0;
    dr ::= r + 1;
    loop {
        if r >= grid_rows { break; }

        put_str(
        screen,
        1 + (row_label_width - (int)str_from_int(r + 1)),
        grid_start_y + r,
        str_from_int(r + 1)
        );

        c = 0;
        dc ::= c + 1;
        loop {
            if c >= grid_cols { break; }
            cell_x = grid_start_x + (c * cell_w) + 1;
            s := cells[r][c];
            if (int)s > 0 {
                put_char(screen, cell_x, grid_start_y + r, s[0]);
            }
            c = dc;
        }
        r = dr;
    }

    put_char(screen, cursor_x_px, cursor_y_px, '@');
}

func render(screen) {
    print "\033[H";
    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        println screen.buf[y];
        y = dy;
    }
    println "\033[?25l";
}

func delay(n) {
    d = 0;
    dd ::= d + 1;
    loop {
        if d >= n { break; }
        d = dd;
    }
}

func main() {
    print "\033[2J";

    w := 80;
    h := 26;

    screen := new_screen(w, h);

    row_label_width = 3;
    cell_w = 4;
    inner_w = w - 2;

    grid_cols ::= clamp((inner_w - row_label_width - 1) / cell_w, 1, 26);
    grid_rows ::= clamp(h - 10, 1, 20);

    grid_start_x ::= 1 + row_label_width;
    grid_start_y ::= 2;

    cursor_x = 0;
    cursor_y = 0;

    cursor_x_px ::= grid_start_x + (cursor_x * cell_w) + 1;
    cursor_y_px ::= grid_start_y + cursor_y;


    cells := [grid_rows];
    r = 0;
    dr ::= r + 1;
    loop {
        if r >= grid_rows { break; }
        cells[r] = [grid_cols];
        c = 0;
        dc ::= c + 1;
        loop {
            if c >= grid_cols { break; }
            cells[r][c] ::= "";
            c = dc;
        }
        r = dr;
    }

    cell_name ::= cell_label(cursor_x, cursor_y);
    cell_value ::= cells[cursor_y][cursor_x];
    cell_type ::= "literal";

    status_line ::=
    edit_mode
    ? str_append("EDIT | Sheet: 0 | Cursor: ", cell_name)
    : str_append("NORMAL | Sheet: 0 | Cursor: ", cell_name);

    edit_mode = 0;
    edit_buffer := "";
    edit_cell_x = 0;
    edit_cell_y = 0;

    input_init();

    loop {
        key := input_poll();
        if key != -1 && edit_mode == 0 {
            if key == KEY_LEFT  { cursor_x = cursor_x - 1; }
            if key == KEY_RIGHT { cursor_x = cursor_x + 1; }
            if key == KEY_UP    { cursor_y = cursor_y - 1; }
            if key == KEY_DOWN  { cursor_y = cursor_y + 1; }
            if key == (int)'q' || key == (int)'Q' { break; }
        }
        if edit_mode == 0 {
            if key == 10 {
                edit_mode = 1;
                edit_buffer = cells[cursor_y][cursor_x];
                edit_cell_x = cursor_x;
                edit_cell_y = cursor_y;
            }
        }
        else {
            if key == 27 {
                edit_mode = 0;
            }
            else if key == 10 {
                cells[edit_cell_y][edit_cell_x] = edit_buffer;
                edit_mode = 0;
            }
            else if key >= 32 && key <= 126 {
                edit_buffer = str_append_char(edit_buffer, (char)key);
            }
        }

        cursor_x = clamp(cursor_x, 0, grid_cols - 1);
        cursor_y = clamp(cursor_y, 0, grid_rows - 1);

        framebuffer(
        screen,
        cursor_x_px,
        cursor_y_px,
        cell_name,
        cell_value,
        cell_type,
        status_line,
        grid_cols,
        grid_rows,
        cells,
        edit_mode,
        edit_buffer
        );

        render(screen);
        delay(4000);
    }

    input_shutdown();
    print "\033[?25h";
}
