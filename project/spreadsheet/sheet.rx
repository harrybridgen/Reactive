import std.input;
import std.str;
import std.maths;
import std.char;

struct Screen {
    width;
    height;
    buf;
}

func new_screen(width, height) {
    screen := struct Screen;
    screen.width := width;
    screen.height := height;
    screen.buf := [screen.height];

    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        screen.buf[y] = [screen.width];
        y = dy;
    }
    return screen;
}

func clear_buf(screen) {
    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        x = 0;
        dx ::= x + 1;
        loop {
            if x >= screen.width { break; }
            screen.buf[y][x] = ' ';
            x = dx;
        }
        y = dy;
    }
}

func put_char(screen, x, y, c) {
    if x < 0 || y < 0 { return 0; }
    if x >= screen.width || y >= screen.height { return 0; }
    screen.buf[y][x] = c;
    return 0;
}

func put_str(screen, x, y, s) {
    n := (int)s;
    i = 0;
    di ::= i + 1;
    loop {
        if i >= n { break; }
        put_char(screen, x + i, y, s[i]);
        i = di;
    }
}

func draw_hline(screen, x0, x1, y, c) {
    x = x0;
    dx ::= x + 1;
    loop {
        if x > x1 { break; }
        put_char(screen, x, y, c);
        x = dx;
    }
}

func draw_vline(screen, x, y0, y1, c) {
    y = y0;
    dy ::= y + 1;
    loop {
        if y > y1 { break; }
        put_char(screen, x, y, c);
        y = dy;
    }
}

func draw_box(screen, x0, y0, x1, y1) {
    draw_hline(screen, x0 + 1, x1 - 1, y0, '-');
    draw_hline(screen, x0 + 1, x1 - 1, y1, '-');
    draw_vline(screen, x0, y0 + 1, y1 - 1, '|');
    draw_vline(screen, x1, y0 + 1, y1 - 1, '|');
    put_char(screen, x0, y0, '+');
    put_char(screen, x1, y0, '+');
    put_char(screen, x0, y1, '+');
    put_char(screen, x1, y1, '+');
}

func cell_label(cx, cy) {
    col := (char)((int)'A' + cx);
    row := str_from_int(cy + 1);
    out := str_empty();
    out = str_append_char(out, col);
    out = str_append(out, row);
    return out;
}

func skip_spaces(s, i) {
    len := (int)s;
    loop {
        if i >= len { break; }
        c := s[i];
        if c != ' ' && c != '\t' { break; }
        i = i + 1;
    }
    return i;
}

func scan_number_len(s, i) {
    len := (int)s;
    n = 0;
    loop {
        if i + n >= len { break; }
        c := s[i + n];
        if !is_digit(c) { break; }
        n = n + 1;
    }
    return n;
}

func scan_number_value(s, i, n) {
    val = 0;
    j = 0;
    dj ::= j + 1;
    loop {
        if j >= n { break; }
        val = val * 10 + ((int)s[i + j] - (int)'0');
        j = dj;
    }
    return val;
}

func str_drop_last(s) {
    len := (int)s;
    if len <= 0 { return ""; }
    out := [len - 1];
    i = 0;
    di ::= i + 1;
    loop {
        if i >= len - 1 { break; }
        out[i] = s[i];
        i = di;
    }
    return out;
}

func cell_literal_value(s) {
    len := (int)s;
    if len == 0 { return 0; }
    if s[0] == '-' {
        nlen := scan_number_len(s, 1);
        if nlen == len - 1 {
            return -scan_number_value(s, 1, nlen);
        }
        return len;
    }
    nlen := scan_number_len(s, 0);
    if nlen == len {
        return scan_number_value(s, 0, nlen);
    }
    return len;
}

func parse_cell_ref(expr, i, out) {
    len := (int)expr;
    i = skip_spaces(expr, i);
    if i >= len { return 0; }
    c := expr[i];
    if !is_alpha(c) { return 0; }
    col = (int)c >= (int)'a' ? (int)c - (int)'a' : (int)c - (int)'A';
    i = i + 1;
    nlen := scan_number_len(expr, i);
    if nlen == 0 { return 0; }
    row := scan_number_value(expr, i, nlen) - 1;
    i = i + nlen;
    out[0] = col;
    out[1] = row;
    out[2] = i;
    return 1;
}

func parse_formula_refs(expr, start, cols, rows, signs, count_out) {
    len := (int)expr;
    i = start;
    sign = 1;
    count = 0;
    ref := [3];
    loop {
        i = skip_spaces(expr, i);
        if i >= len { break; }
        c := expr[i];
        if c == '+' {
            sign = 1;
            i = i + 1;
            continue;
        }
        if c == '-' {
            sign = -1;
            i = i + 1;
            continue;
        }
        if !parse_cell_ref(expr, i, ref) { return 0; }
        cols[count] = ref[0];
        rows[count] = ref[1];
        signs[count] = sign;
        count = count + 1;
        i = ref[2];
        sign = 1;
    }
    count_out[0] = count;
    return count > 0;
}

func sum_formula_refs(cells_value, cols, rows, signs, count, grid_cols, grid_rows) {
    total = 0;
    i = 0;
    di ::= i + 1;
    loop {
        if i >= count { break; }
        cx := cols[i];
        cy := rows[i];
        if cx >= 0 && cy >= 0 && cx < grid_cols && cy < grid_rows {
            total = total + (signs[i] * cells_value[cy][cx]);
        }
        i = di;
    }
    return total;
}

func apply_cell_text(cells_text, cells_value, grid_cols, grid_rows, x, y) {
    s := cells_text[y][x];
    if (int)s == 0 {
        cells_value[y][x] = 0;
        return 0;
    }
    if s[0] != '=' {
        cells_value[y][x] = cell_literal_value(s);
        return 0;
    }
    max_terms := (int)s;
    cols := [max_terms];
    rows := [max_terms];
    signs := [max_terms];
    count_out := [1];
    if !parse_formula_refs(s, 1, cols, rows, signs, count_out) {
        cells_value[y][x] = 0;
        return 0;
    }
    count := count_out[0];
    cells_value[y][x] ::= sum_formula_refs(
    cells_value,
    cols,
    rows,
    signs,
    count,
    grid_cols,
    grid_rows
    );
    return 0;
}

func cell_display_value(cells_text, cells_value, grid_cols, grid_rows, x, y) {
    if x < 0 || y < 0 { return ""; }
    if x >= grid_cols || y >= grid_rows { return ""; }
    s := cells_text[y][x];
    if (int)s == 0 { return ""; }
    if s[0] == '=' {
        return str_from_int(cells_value[y][x]);
    }
    return s;
}

func cell_display_type(cells_text, grid_cols, grid_rows, x, y) {
    if x < 0 || y < 0 { return "literal"; }
    if x >= grid_cols || y >= grid_rows { return "literal"; }
    s := cells_text[y][x];
    if (int)s == 0 { return "literal"; }
    if s[0] == '=' {
        return "formula";
    }
    return "literal";
}

func framebuffer(
screen,
cursor_x_px,
cursor_y_px,
cell_name,
cell_value,
cell_type,
status_line,
grid_cols,
grid_rows,
cells_text,
cells_value,
edit_mode,
edit_buffer
) {
    clear_buf(screen);

    title := "ReactiveSheet";
    w := screen.width;

    row_label_width = 3;
    cell_w = 4;

    grid_start_x = 1 + row_label_width;
    grid_start_y = 2;

    sep1_y = grid_start_y + grid_rows + 1;
    info_y = sep1_y + 1;
    sep2_y = info_y + 3;
    status_y = sep2_y + 1;

    draw_box(screen, 0, 0, w - 1, screen.height - 1);

    put_str(screen, (w - (int)title) / 2, 0, title);

    draw_hline(screen, 1, w - 2, sep1_y, '-');
    draw_hline(screen, 1, w - 2, sep2_y, '-');

    put_str(screen, 1, info_y + 0, str_append("Cell: ", cell_name));
    if edit_mode {
        put_str(screen, 1, info_y + 1, str_append("Edit: ", edit_buffer));
    }
    else {
        put_str(screen, 1, info_y + 1, str_append("Value: ", cell_value));
    }
    put_str(screen, 1, info_y + 2, str_append("Type: ", cell_type));

    put_str(screen, 1, status_y, status_line);

    c = 0;
    dc ::= c + 1;
    loop {
        if c >= grid_cols { break; }
        col_x = grid_start_x + (c * cell_w) + 1;
        put_char(screen, col_x, 1, (char)((int)'A' + c));
        c = dc;
    }

    r = 0;
    dr ::= r + 1;
    grid_max_x := grid_start_x + (grid_cols * cell_w);
    if grid_max_x > w - 2 { grid_max_x = w - 2; }
    loop {
        if r >= grid_rows { break; }

        put_str(
        screen,
        1 + (row_label_width - (int)str_from_int(r + 1)),
        grid_start_y + r,
        str_from_int(r + 1)
        );

        c = 0;
        dc ::= c + 1;
        last_covered_x = -1;
        loop {
            if c >= grid_cols { break; }
            cell_x = grid_start_x + (c * cell_w) + 1;
            if last_covered_x < cell_x {
                s := cell_display_value(cells_text, cells_value, grid_cols, grid_rows, c, r);
                n := (int)s;
                if n > 0 {
                    i = 0;
                    di ::= i + 1;
                    loop {
                        if i >= n { break; }
                        x := cell_x + i;
                        if x > grid_max_x { break; }
                        put_char(screen, x, grid_start_y + r, s[i]);
                        i = di;
                    }
                    end_x := cell_x + n - 1;
                    if end_x > grid_max_x { end_x = grid_max_x; }
                    if end_x > last_covered_x { last_covered_x = end_x; }
                }
            }
            c = dc;
        }
        r = dr;
    }

    put_char(screen, cursor_x_px, cursor_y_px, '@');
}

func render(screen) {
    print "\033[H";
    y = 0;
    dy ::= y + 1;
    loop {
        if y >= screen.height { break; }
        println screen.buf[y];
        y = dy;
    }
    println "\033[?25l";
}

func delay(n) {
    d = 0;
    dd ::= d + 1;
    loop {
        if d >= n { break; }
        d = dd;
    }
}

func main() {
    print "\033[2J";

    w := 80;
    h := 26;

    screen := new_screen(w, h);

    row_label_width = 3;
    cell_w = 4;
    inner_w = w - 2;

    grid_cols ::= clamp((inner_w - row_label_width - 1) / cell_w, 1, 26);
    grid_rows ::= clamp(h - 10, 1, 20);

    grid_start_x ::= 1 + row_label_width;
    grid_start_y ::= 2;

    cursor_x = 0;
    cursor_y = 0;

    cursor_x_px ::= grid_start_x + (cursor_x * cell_w) + 1;
    cursor_y_px ::= grid_start_y + cursor_y;


    cells_text := [grid_rows];
    cells_value := [grid_rows];
    r = 0;
    dr ::= r + 1;
    loop {
        if r >= grid_rows { break; }
        cells_text[r] = [grid_cols];
        cells_value[r] = [grid_cols];
        c = 0;
        dc ::= c + 1;
        loop {
            if c >= grid_cols { break; }
            cells_text[r][c] ::= "";
            cells_value[r][c] = 0;
            c = dc;
        }
        r = dr;
    }

    cell_name ::= cell_label(cursor_x, cursor_y);
    cell_value ::= cell_display_value(cells_text, cells_value, grid_cols, grid_rows, cursor_x, cursor_y);
    cell_type ::= cell_display_type(cells_text, grid_cols, grid_rows, cursor_x, cursor_y);

    status_line ::=
    edit_mode
    ? str_append("EDIT | Sheet: 0 | Cursor: ", cell_name)
    : str_append("NORMAL | Sheet: 0 | Cursor: ", cell_name);

    edit_mode = 0;
    edit_buffer := "";
    edit_cell_x = 0;
    edit_cell_y = 0;

    input_init();

    loop {
        key := input_poll();
        if key != -1 && edit_mode == 0 {
            if key == KEY_LEFT  { cursor_x = cursor_x - 1; }
            if key == KEY_RIGHT { cursor_x = cursor_x + 1; }
            if key == KEY_UP    { cursor_y = cursor_y - 1; }
            if key == KEY_DOWN  { cursor_y = cursor_y + 1; }
            if key == (int)'q' || key == (int)'Q' { break; }
        }
        if edit_mode == 0 {
            if key == 10 {
                edit_mode = 1;
                edit_buffer = cells_text[cursor_y][cursor_x];
                edit_cell_x = cursor_x;
                edit_cell_y = cursor_y;
            }
        }
        else {
            if key == 27 {
                edit_mode = 0;
            }
            else if key == 10 {
                cells_text[edit_cell_y][edit_cell_x] = edit_buffer;
                apply_cell_text(cells_text, cells_value, grid_cols, grid_rows, edit_cell_x, edit_cell_y);
                edit_mode = 0;
            }
            else if key == 8 || key == 127 {
                edit_buffer = str_drop_last(edit_buffer);
            }
            else if key >= 32 && key <= 126 {
                edit_buffer = str_append_char(edit_buffer, (char)key);
            }
        }

        cursor_x = clamp(cursor_x, 0, grid_cols - 1);
        cursor_y = clamp(cursor_y, 0, grid_rows - 1);

        framebuffer(
        screen,
        cursor_x_px,
        cursor_y_px,
        cell_name,
        cell_value,
        cell_type,
        status_line,
        grid_cols,
        grid_rows,
        cells_text,
        cells_value,
        edit_mode,
        edit_buffer
        );

        render(screen);
        delay(4000);
    }

    input_shutdown();
    print "\033[?25h";
}
