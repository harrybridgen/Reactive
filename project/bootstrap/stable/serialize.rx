import bootstrap.stable.grammar;
import bootstrap.stable.util;
import std.buf;

#
-----------------------------------------
Serializer buffer helpers
-----------------------------------------
#
struct TextBuf {
    buf;
    first = 1;
}

func textbuf_new(cap) {
    out := struct TextBuf;
    out.buf = buf_new(cap);
    out.first = 1;
    return out;
}

func textbuf_line_start(out) {
    if out.first == 0 {
        buf_push_char(out.buf, '\n');
    }
    else {
        out.first = 0;
    }
}

func textbuf_push(out, s) {
    buf_push_str(out.buf, s);
}

func textbuf_push_char(out, c) {
    buf_push_char(out.buf, c);
}

func textbuf_finish(out) {
    return buf_to_string(out.buf);
}

func append_int(out, n) {
    textbuf_push(out, str_from_int(n));
}

func append_quoted(out, s) {
    textbuf_push_char(out, '"');

    i = 0;
    di ::= i + 1;
    loop {
        if i >= s { break; }
        c := s[i];
        ci := (int)c;

        if c == '\\' {
            textbuf_push(out, "\\\\");
        }
        else if c == '"' {
            textbuf_push(out, "\\\"");
        }
        else if c == '\n' {
            textbuf_push(out, "\\n");
        }
        else if c == '\r' {
            textbuf_push(out, "\\r");
        }
        else if c == '\t' {
            textbuf_push(out, "\\t");
        }
        else if ci < 32 || ci > 126 {
            textbuf_push(out, "\\u{");
            textbuf_push(out, str_from_hex(ci));
            textbuf_push_char(out, '}');
        }
        else {
            textbuf_push_char(out, c);
        }

        i = di;
    }

    textbuf_push_char(out, '"');
}

#
-----------------------------------------
Instruction serialization
-----------------------------------------
#
func serialize_instructions(code) {
    out := textbuf_new(1024);
    textbuf_line_start(out);
    textbuf_push(out, "RXB1");
    append_instructions(out, code);
    return textbuf_finish(out);
}

func append_instructions(out, code) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= code { break; }
        append_instruction(out, code[i]);
        i = di;
    }
}

func append_instruction(out, instr) {
    if instr.kind == INSTR_Push {
        textbuf_line_start(out);
        textbuf_push(out, "Push ");
        append_int(out, instr.a);
        return;
    }
    if instr.kind == INSTR_PushChar {
        textbuf_line_start(out);
        textbuf_push(out, "PushChar ");
        append_int(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Load {
        textbuf_line_start(out);
        textbuf_push(out, "Load ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Store {
        textbuf_line_start(out);
        textbuf_push(out, "Store ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreImmutable {
        textbuf_line_start(out);
        textbuf_push(out, "StoreImmutable ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreReactive {
        append_reactive_named(out, "StoreReactive", instr.a, instr.b);
        return;
    }

    if instr.kind == INSTR_Add { textbuf_line_start(out); textbuf_push(out, "Add"); return; }
    if instr.kind == INSTR_Sub { textbuf_line_start(out); textbuf_push(out, "Sub"); return; }
    if instr.kind == INSTR_Mul { textbuf_line_start(out); textbuf_push(out, "Mul"); return; }
    if instr.kind == INSTR_Div { textbuf_line_start(out); textbuf_push(out, "Div"); return; }
    if instr.kind == INSTR_Modulo { textbuf_line_start(out); textbuf_push(out, "Modulo"); return; }

    if instr.kind == INSTR_Greater { textbuf_line_start(out); textbuf_push(out, "Greater"); return; }
    if instr.kind == INSTR_Less { textbuf_line_start(out); textbuf_push(out, "Less"); return; }
    if instr.kind == INSTR_GreaterEqual { textbuf_line_start(out); textbuf_push(out, "GreaterEqual"); return; }
    if instr.kind == INSTR_LessEqual { textbuf_line_start(out); textbuf_push(out, "LessEqual"); return; }
    if instr.kind == INSTR_Equal { textbuf_line_start(out); textbuf_push(out, "Equal"); return; }
    if instr.kind == INSTR_NotEqual { textbuf_line_start(out); textbuf_push(out, "NotEqual"); return; }
    if instr.kind == INSTR_And { textbuf_line_start(out); textbuf_push(out, "And"); return; }
    if instr.kind == INSTR_Or { textbuf_line_start(out); textbuf_push(out, "Or"); return; }

    if instr.kind == INSTR_Label {
        textbuf_line_start(out);
        textbuf_push(out, "Label ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Jump {
        textbuf_line_start(out);
        textbuf_push(out, "Jump ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_JumpIfZero {
        textbuf_line_start(out);
        textbuf_push(out, "JumpIfZero ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_Return {
        textbuf_line_start(out);
        textbuf_push(out, "Return");
        return;
    }

    if instr.kind == INSTR_ArrayNew { textbuf_line_start(out); textbuf_push(out, "ArrayNew"); return; }
    if instr.kind == INSTR_ArrayGet { textbuf_line_start(out); textbuf_push(out, "ArrayGet"); return; }
    if instr.kind == INSTR_ArrayLValue { textbuf_line_start(out); textbuf_push(out, "ArrayLValue"); return; }

    if instr.kind == INSTR_StoreIndex {
        textbuf_line_start(out);
        textbuf_push(out, "StoreIndex ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_StoreIndexReactive {
        append_reactive_named(out, "StoreIndexReactive", instr.a, instr.b);
        return;
    }

    if instr.kind == INSTR_StoreStruct {
        append_store_struct(out, instr.a, instr.b);
        return;
    }
    if instr.kind == INSTR_NewStruct {
        textbuf_line_start(out);
        textbuf_push(out, "NewStruct ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldGet {
        textbuf_line_start(out);
        textbuf_push(out, "FieldGet ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldSet {
        textbuf_line_start(out);
        textbuf_push(out, "FieldSet ");
        append_quoted(out, instr.a);
        return;
    }
    if instr.kind == INSTR_FieldSetReactive {
        append_reactive_named(out, "FieldSetReactive", instr.a, instr.b);
        return;
    }
    if instr.kind == INSTR_FieldLValue {
        textbuf_line_start(out);
        textbuf_push(out, "FieldLValue ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_StoreThrough { textbuf_line_start(out); textbuf_push(out, "StoreThrough"); return; }
    if instr.kind == INSTR_StoreThroughReactive {
        append_reactive_unnamed(out, "StoreThroughReactive", instr.a);
        return;
    }
    if instr.kind == INSTR_StoreThroughImmutable {
        textbuf_line_start(out);
        textbuf_push(out, "StoreThroughImmutable");
        return;
    }

    if instr.kind == INSTR_StoreFunction {
        append_store_function(out, instr.a, instr.b, instr.c);
        return;
    }
    if instr.kind == INSTR_Call {
        textbuf_line_start(out);
        textbuf_push(out, "Call ");
        append_quoted(out, instr.a);
        textbuf_push(out, " ");
        append_int(out, instr.b);
        return;
    }

    if instr.kind == INSTR_PushImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "PushImmutableContext");
        return;
    }
    if instr.kind == INSTR_PopImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "PopImmutableContext");
        return;
    }
    if instr.kind == INSTR_ClearImmutableContext {
        textbuf_line_start(out);
        textbuf_push(out, "ClearImmutableContext");
        return;
    }

    if instr.kind == INSTR_Print { textbuf_line_start(out); textbuf_push(out, "Print"); return; }
    if instr.kind == INSTR_Println { textbuf_line_start(out); textbuf_push(out, "Println"); return; }
    if instr.kind == INSTR_Assert { textbuf_line_start(out); textbuf_push(out, "Assert"); return; }
    if instr.kind == INSTR_Error {
        textbuf_line_start(out);
        textbuf_push(out, "Error ");
        append_quoted(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Import {
        append_import(out, instr.a);
        return;
    }

    if instr.kind == INSTR_Cast {
        textbuf_line_start(out);
        textbuf_push(out, "Cast ");
        if instr.a == CAST_Int {
            textbuf_push(out, "Int");
        }
        else {
            textbuf_push(out, "Char");
        }
        return;
    }

    error "serialize: unknown instruction";
}

func append_import(out, path) {
    textbuf_line_start(out);
    textbuf_push(out, "Import ");
    append_int(out, (int)path);
    i = 0;
    di ::= i + 1;
    loop {
        if i >= path { break; }
        textbuf_push(out, " ");
        append_quoted(out, path[i]);
        i = di;
    }
}

func append_store_function(out, name, params, body) {
    textbuf_line_start(out);
    textbuf_push(out, "StoreFunction ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)params);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= params { break; }
        textbuf_push(out, " ");
        append_quoted(out, params[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)body);

    append_instructions(out, body);
}

func append_store_struct(out, name, fields) {
    textbuf_line_start(out);
    textbuf_push(out, "StoreStruct ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)fields);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= fields { break; }
        append_struct_field(out, fields[i]);
        i = di;
    }
}

func append_struct_field(out, field) {
    if field.kind == FIELD_INIT_None {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " None");
        return;
    }

    if field.kind == FIELD_INIT_Mutable {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Mutable ");
        append_int(out, (int)field.value);
        append_instructions(out, field.value);
        return;
    }

    if field.kind == FIELD_INIT_Immutable {
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Immutable ");
        append_int(out, (int)field.value);
        append_instructions(out, field.value);
        return;
    }

    if field.kind == FIELD_INIT_Reactive {
        expr := field.value;
        textbuf_line_start(out);
        textbuf_push(out, "Field ");
        append_quoted(out, field.name);
        textbuf_push(out, " Reactive ");
        append_int(out, (int)expr.captures);

        i = 0;
        di ::= i + 1;
        loop {
            if i >= expr.captures { break; }
            textbuf_push(out, " ");
            append_quoted(out, expr.captures[i]);
            i = di;
        }

        textbuf_push(out, " ");
        append_int(out, (int)expr.code);

        append_instructions(out, expr.code);
        return;
    }

    error "serialize: unknown field init";
}

func append_reactive_named(out, keyword, name, expr) {
    textbuf_line_start(out);
    textbuf_push(out, keyword);
    textbuf_push(out, " ");
    append_quoted(out, name);
    textbuf_push(out, " ");
    append_int(out, (int)expr.captures);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= expr.captures { break; }
        textbuf_push(out, " ");
        append_quoted(out, expr.captures[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)expr.code);

    append_instructions(out, expr.code);
}

func append_reactive_unnamed(out, keyword, expr) {
    textbuf_line_start(out);
    textbuf_push(out, keyword);
    textbuf_push(out, " ");
    append_int(out, (int)expr.captures);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= expr.captures { break; }
        textbuf_push(out, " ");
        append_quoted(out, expr.captures[i]);
        i = di;
    }

    textbuf_push(out, " ");
    append_int(out, (int)expr.code);

    append_instructions(out, expr.code);
}
