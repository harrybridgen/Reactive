import bootstrap.experimental.grammar;
import bootstrap.experimental.serialize;
import bootstrap.experimental.tokenizer;
import bootstrap.experimental.parser;
import std.vec;
import std.str;
import std.file;

#
-----------------------------------------
Helpers
-----------------------------------------
#
struct LabelGen {
    counter = 0;
}

func new_labelgen() {
    lg := struct LabelGen;
    lg.counter = 0;
    return lg;
}

func label_fresh(lg, prefix) {
    name := str_append(prefix, "_");
    name = str_append(name, str_from_int(lg.counter));
    lg.counter = lg.counter + 1;
    return name;
}

func vec_contains_str(v, s) {
    i = 0;
    di ::= i + 1;
    n := (int)v;
    loop {
        if i >= n { break; }
        if str_equals(v[i], s) {
            return 1;
        }
        i = di;
    }
    return 0;
}

func vec_push_unique(v, s) {
    if vec_contains_str(v, s) {
        return;
    }
    vec_push(v, s);
}

func vec_sort_strings(v) {
    i = 1;
    di ::= i + 1;
    n := (int)v;
    loop {
        if i >= n { break; }
        key := v[i];
        j = i - 1;
        loop {
            if j < 0 { break; }
            if str_compare(v[j], key) <= 0 { break; }
            v[j + 1] = v[j];
            j = j - 1;
        }
        v[j + 1] = key;
        i = di;
    }
}

func join_segments(parts, sep) {
    out := str_empty();
    i = 0;
    di ::= i + 1;
    loop {
        if i >= parts { break; }
        if i > 0 {
            out = str_append(out, sep);
        }
        out = str_append(out, parts[i]);
        i = di;
    }
    return out;
}

#
-----------------------------------------
Compiler entrypoints
-----------------------------------------
#
func compile_source(src) {
    lex := tokenize(src);
    ast := parse(lex.tokens, lex.len);

    code := vec_new(64);
    labels := new_labelgen();
    break_stack := vec_new(8);
    continue_stack := vec_new(8);
    imports := vec_new(8);
    println "[Reactive] Compiler"
    compile(ast, code, labels, break_stack, continue_stack, imports);
    return vec_to_array(code);
}

func compile_source_module(src) {
    lex := tokenize(src);
    ast := parse(lex.tokens, lex.len);

    code := vec_new(64);
    labels := new_labelgen();
    break_stack := vec_new(8);
    continue_stack := vec_new(8);
    imports := vec_new(8);
    println "[Reactive] Compiler (module)"
    compile_module(ast, code, labels, break_stack, continue_stack, imports);
    return vec_to_array(code);
}

func compile_file(input_path, output_path) {
    src := file_read(input_path);
    code := compile_source(src);
    println "[Reactive] Serialize";
    text := serialize_instructions(code);
    println "[Reactive] Write file";
    file_write(output_path, text);
}

func compile_file_module(input_path, output_path) {
    src := file_read(input_path);
    code := compile_source_module(src);
    println "[Reactive] Serialize";
    text := serialize_instructions(code);
    println "[Reactive] Write file";
    file_write(output_path, text);
}

#
-----------------------------------------
Compilation (AST -> instructions)
-----------------------------------------
#
func compile_module(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Program {
        items := ast.list;
        i = 0;
        di ::= i + 1;
        loop {
            if i >= items { break; }
            compile(items[i], code, labels, break_stack, continue_stack, imports);
            i = di;
        }
    }
    else {
        compile(ast, code, labels, break_stack, continue_stack, imports);
    }
}

func compile(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Number {
        value := ast.a;
        inst := instr1(INSTR_Push, value);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Char {
        value := ast.a;
        inst := instr1(INSTR_PushChar, value);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_String {
        value := ast.a;
        compile_string_literal(value, code, labels);
        return;
    }
    if ast.kind == AST_Var {
        inst := instr1(INSTR_Load, ast.name);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_ArrayNew {
        size := ast.a;
        compile(size, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayNew);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        compile(base, code, labels, break_stack, continue_stack, imports);
        compile(index, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayGet);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        compile(base, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_FieldGet, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Operation {
        left := ast.a;
        right := ast.b;
        compile(left, code, labels, break_stack, continue_stack, imports);
        compile(right, code, labels, break_stack, continue_stack, imports);
        emit_operator(ast.op, code);
        return;
    }
    if ast.kind == AST_Ternary {
        cond := ast.a;
        then_expr := ast.b;
        else_expr := ast.c;
        compile(cond, code, labels, break_stack, continue_stack, imports);

        else_lbl := label_fresh(labels, "ternary_else");
        end_lbl := label_fresh(labels, "ternary_end");

        inst := instr1(INSTR_JumpIfZero, else_lbl);
        vec_push(code, inst);
        compile(then_expr, code, labels, break_stack, continue_stack, imports);
        inst = instr1(INSTR_Jump, end_lbl);
        vec_push(code, inst);

        inst = instr1(INSTR_Label, else_lbl);
        vec_push(code, inst);
        compile(else_expr, code, labels, break_stack, continue_stack, imports);

        inst = instr1(INSTR_Label, end_lbl);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Call {
        args := ast.list;
        i = 0;
        di ::= i + 1;
        loop {
            if i >= args { break; }
            compile(args[i], code, labels, break_stack, continue_stack, imports);
            i = di;
        }
        inst := instr2(INSTR_Call, ast.name, (int)args);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Assign {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_Store, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ImmutableAssign {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_StoreImmutable, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ReactiveAssign {
        value := ast.a;
        reactive := compile_reactive_expr(value, imports);
        name := ast.name;
        inst := instr2(INSTR_StoreReactive, name, reactive);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_AssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_StoreThrough);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ReactiveAssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        reactive := compile_reactive_expr(value, imports);
        inst := instr1(INSTR_StoreThroughReactive, reactive);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_ImmutableAssignTarget {
        target := ast.a;
        value := ast.b;
        compile_lvalue(target, code, labels, break_stack, continue_stack, imports);
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_StoreThroughImmutable);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAssign {
        if ast.flag == FIELD_ASSIGN_Normal {
            base := ast.a;
            value := ast.b;
            compile(base, code, labels, break_stack, continue_stack, imports);
            compile(value, code, labels, break_stack, continue_stack, imports);
            name := ast.name;
            inst := instr1(INSTR_FieldSet, name);
            vec_push(code, inst);
            return;
        }
        if ast.flag == FIELD_ASSIGN_Reactive {
            base := ast.a;
            value := ast.b;
            compile(base, code, labels, break_stack, continue_stack, imports);
            reactive := compile_reactive_expr(value, imports);
            name := ast.name;
            inst := instr2(INSTR_FieldSetReactive, name, reactive);
            vec_push(code, inst);
            return;
        }
        error "compiler: immutable field assignment not allowed";
    }

    if ast.kind == AST_IfElse {
        cond := ast.a;
        then_block := ast.b;
        else_block := ast.c;
        compile(cond, code, labels, break_stack, continue_stack, imports);

        else_lbl := label_fresh(labels, "else");
        end_lbl := label_fresh(labels, "ifend");

        inst := instr1(INSTR_JumpIfZero, else_lbl);
        vec_push(code, inst);

        inst = instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        compile_block(then_block, code, labels, break_stack, continue_stack, imports);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        inst = instr1(INSTR_Jump, end_lbl);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, else_lbl);
        vec_push(code, inst);

        inst = instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        compile_block(else_block, code, labels, break_stack, continue_stack, imports);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        inst = instr1(INSTR_Label, end_lbl);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Loop {
        start := label_fresh(labels, "loop_start");
        end := label_fresh(labels, "loop_end");

        vec_push(break_stack, end);
        vec_push(continue_stack, start);

        inst := instr0(INSTR_PushImmutableContext);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, start);
        vec_push(code, inst);
        inst = instr0(INSTR_ClearImmutableContext);
        vec_push(code, inst);

        compile_block(ast.list, code, labels, break_stack, continue_stack, imports);

        inst = instr1(INSTR_Jump, start);
        vec_push(code, inst);
        inst = instr1(INSTR_Label, end);
        vec_push(code, inst);
        inst = instr0(INSTR_PopImmutableContext);
        vec_push(code, inst);

        vec_pop(break_stack);
        vec_pop(continue_stack);
        return;
    }

    if ast.kind == AST_Break {
        label := vec_last(break_stack);
        inst := instr1(INSTR_Jump, label);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Continue {
        label := vec_last(continue_stack);
        inst := instr1(INSTR_Jump, label);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Return {
        if ast.flag == 1 {
            value := ast.a;
            compile(value, code, labels, break_stack, continue_stack, imports);
        }
        else {
            inst := instr1(INSTR_Push, 0);
            vec_push(code, inst);
        }
        inst = instr0(INSTR_Return);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_FuncDef {
        func_code := compile_function_body(ast.body, imports);
        inst := instr3(INSTR_StoreFunction, ast.name, ast.params, func_code);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_StructDef {
        fields := compile_struct_fields(ast.list, imports);
        inst := instr2(INSTR_StoreStruct, ast.name, fields);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_StructNew {
        inst := instr1(INSTR_NewStruct, ast.name);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Import {
        compile_import(ast.list, code, labels, break_stack, continue_stack, imports);
        return;
    }

    if ast.kind == AST_Program {
        items := ast.list;
        has_main = 0;

        i = 0;
        di ::= i + 1;
        loop {
            if i >= items { break; }
            item := items[i];
            if item.kind == AST_FuncDef {
                if str_equals(item.name, "main") {
                    has_main = 1;
                }
            }
            compile(item, code, labels, break_stack, continue_stack, imports);
            i = di;
        }

        if has_main == 0 {
            error "no `main` function defined";
        }

        inst := instr2(INSTR_Call, "main", 0);
        vec_push(code, inst);
        inst = instr0(INSTR_Return);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Print {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Print);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Println {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Println);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Assert {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_Assert);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Error {
        msg := ast.a;
        inst := instr1(INSTR_Error, msg);
        vec_push(code, inst);
        return;
    }

    if ast.kind == AST_Cast {
        value := ast.a;
        compile(value, code, labels, break_stack, continue_stack, imports);
        flag := ast.flag;
        inst := instr1(INSTR_Cast, flag);
        vec_push(code, inst);
        return;
    }

    error "compiler: unknown AST node";
}

#
-----------------------------------------
Block / expression helpers
-----------------------------------------
#
func compile_block(block, code, labels, break_stack, continue_stack, imports) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= block { break; }
        compile(block[i], code, labels, break_stack, continue_stack, imports);
        i = di;
    }
}

func compile_function_body(body, imports) {
    code := vec_new(16);
    labels := new_labelgen();
    break_stack := vec_new(4);
    continue_stack := vec_new(4);

    compile_block(body, code, labels, break_stack, continue_stack, imports);
    inst := instr0(INSTR_Return);
    vec_push(code, inst);
    return vec_to_array(code);
}

func compile_struct_fields(fields, imports) {
    out := vec_new(8);
    i = 0;
    di ::= i + 1;
    loop {
        if i >= fields { break; }
        f := fields[i];
        if f.kind == FIELD_INIT_None {
            init := field_init(f.name, FIELD_INIT_None, 0);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Mutable {
            code := compile_expr_to_code(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Mutable, code);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Immutable {
            code := compile_expr_to_code(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Immutable, code);
            vec_push(out, init);
        }
        else if f.kind == FIELD_INIT_Reactive {
            reactive := compile_reactive_expr(f.value, imports);
            init := field_init(f.name, FIELD_INIT_Reactive, reactive);
            vec_push(out, init);
        }
        else {
            error "compiler: unknown field init kind";
        }
        i = di;
    }
    return vec_to_array(out);
}

func compile_expr_to_code(ast, imports) {
    code := vec_new(8);
    labels := new_labelgen();
    break_stack := vec_new(4);
    continue_stack := vec_new(4);

    compile(ast, code, labels, break_stack, continue_stack, imports);
    inst := instr0(INSTR_Return);
    vec_push(code, inst);
    return vec_to_array(code);
}

func compile_reactive_expr(ast, imports) {
    names := vec_new(8);
    collect_free_vars(ast, names);
    vec_sort_strings(names);
    code := compile_expr_to_code(ast, imports);
    return reactive_expr(vec_to_array(names), code);
}

#
-----------------------------------------
Free variable collection (reactive captures)
-----------------------------------------
#
func collect_free_vars_list(list, out) {
    i = 0;
    di ::= i + 1;
    loop {
        if i >= list { break; }
        collect_free_vars(list[i], out);
        i = di;
    }
}

func collect_free_vars(ast, out) {
    if ast.kind == AST_Var {
        vec_push_unique(out, ast.name);
        return;
    }
    if ast.kind == AST_Operation {
        left := ast.a;
        right := ast.b;
        collect_free_vars(left, out);
        collect_free_vars(right, out);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        collect_free_vars(base, out);
        collect_free_vars(index, out);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        collect_free_vars(base, out);
        return;
    }
    if ast.kind == AST_Ternary {
        cond := ast.a;
        then_expr := ast.b;
        else_expr := ast.c;
        collect_free_vars(cond, out);
        collect_free_vars(then_expr, out);
        collect_free_vars(else_expr, out);
        return;
    }
    if ast.kind == AST_Call {
        collect_free_vars_list(ast.list, out);
        return;
    }
    if ast.kind == AST_ArrayNew {
        size := ast.a;
        collect_free_vars(size, out);
        return;
    }
    if ast.kind == AST_Assign ||
    ast.kind == AST_ImmutableAssign ||
    ast.kind == AST_ReactiveAssign {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_AssignTarget || ast.kind == AST_ReactiveAssignTarget {
        target := ast.a;
        value := ast.b;
        collect_free_vars(target, out);
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_ImmutableAssignTarget {
        value := ast.b;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_FieldAssign {
        base := ast.a;
        value := ast.b;
        collect_free_vars(base, out);
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_Cast {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
    if ast.kind == AST_Assert {
        value := ast.a;
        collect_free_vars(value, out);
        return;
    }
}

#
-----------------------------------------
LValue compilation
-----------------------------------------
#
func compile_lvalue(ast, code, labels, break_stack, continue_stack, imports) {
    if ast.kind == AST_Var {
        name := ast.name;
        inst := instr1(INSTR_Load, name);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_Index {
        base := ast.a;
        index := ast.b;
        compile_lvalue(base, code, labels, break_stack, continue_stack, imports);
        compile(index, code, labels, break_stack, continue_stack, imports);
        inst := instr0(INSTR_ArrayLValue);
        vec_push(code, inst);
        return;
    }
    if ast.kind == AST_FieldAccess {
        base := ast.a;
        compile_lvalue(base, code, labels, break_stack, continue_stack, imports);
        name := ast.name;
        inst := instr1(INSTR_FieldLValue, name);
        vec_push(code, inst);
        return;
    }
    error "compiler: invalid assignment target";
}

#
-----------------------------------------
Imports
-----------------------------------------
#
func compile_import(path, code, labels, break_stack, continue_stack, imports) {
    inst := instr1(INSTR_Import, path);
    vec_push(code, inst);

    module_name := join_segments(path, ".");
    if vec_contains_str(imports, module_name) {
        return;
    }
    vec_push(imports, module_name);

    rel_path := join_segments(path, "/");
    file_path := str_append("project/", rel_path);
    file_path = str_append(file_path, ".rx");

    source := file_read(file_path);
    lex := tokenize(source);
    ast := parse(lex.tokens, lex.len);

    compile_module(ast, code, labels, break_stack, continue_stack, imports);
}

#
-----------------------------------------
Operators
-----------------------------------------
#
func emit_operator(op, code) {
    if op == OP_Add { inst := instr0(INSTR_Add); vec_push(code, inst); return; }
    if op == OP_Sub { inst := instr0(INSTR_Sub); vec_push(code, inst); return; }
    if op == OP_Mul { inst := instr0(INSTR_Mul); vec_push(code, inst); return; }
    if op == OP_Div { inst := instr0(INSTR_Div); vec_push(code, inst); return; }
    if op == OP_Mod { inst := instr0(INSTR_Modulo); vec_push(code, inst); return; }
    if op == OP_Greater { inst := instr0(INSTR_Greater); vec_push(code, inst); return; }
    if op == OP_Less { inst := instr0(INSTR_Less); vec_push(code, inst); return; }
    if op == OP_GreaterEqual { inst := instr0(INSTR_GreaterEqual); vec_push(code, inst); return; }
    if op == OP_LessEqual { inst := instr0(INSTR_LessEqual); vec_push(code, inst); return; }
    if op == OP_Equal { inst := instr0(INSTR_Equal); vec_push(code, inst); return; }
    if op == OP_NotEqual { inst := instr0(INSTR_NotEqual); vec_push(code, inst); return; }
    if op == OP_And { inst := instr0(INSTR_And); vec_push(code, inst); return; }
    if op == OP_Or { inst := instr0(INSTR_Or); vec_push(code, inst); return; }
    error "compiler: unknown operator";
}

#
-----------------------------------------
String literals
-----------------------------------------
#
func compile_string_literal(s, code, labels) {
    len := str_len(s);
    inst := instr1(INSTR_Push, len);
    vec_push(code, inst);
    inst = instr0(INSTR_ArrayNew);
    vec_push(code, inst);

    tmp := label_fresh(labels, "__strlit");
    inst = instr1(INSTR_Store, tmp);
    vec_push(code, inst);

    i = 0;
    di ::= i + 1;
    loop {
        if i >= len { break; }
        inst = instr1(INSTR_Load, tmp);
        vec_push(code, inst);
        inst = instr1(INSTR_Push, i);
        vec_push(code, inst);
        inst = instr0(INSTR_ArrayLValue);
        vec_push(code, inst);
        inst = instr1(INSTR_PushChar, s[i]);
        vec_push(code, inst);
        inst = instr0(INSTR_StoreThrough);
        vec_push(code, inst);
        i = di;
    }

    inst = instr1(INSTR_Load, tmp);
    vec_push(code, inst);
}

